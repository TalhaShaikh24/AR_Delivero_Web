"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/checkout/page",{

/***/ "(app-pages-browser)/./services/auth-service.ts":
/*!**********************************!*\
  !*** ./services/auth-service.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthService: () => (/* binding */ AuthService)\n/* harmony export */ });\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n\n/**\n * Service for authentication-related API calls\n */ const AuthService = {\n    /**\n   * Register a new user\n   */ register: async function(email, username) {\n        let password = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"123456\", loginType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"email\";\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.post(\"api/v1/user/register\", {\n                email,\n                username,\n                password,\n                loginType\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Failed to register user:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Login a user\n   */ login: async (email, password)=>{\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.post('api/v1/user/user-login', {\n                email,\n                password\n            });\n            localStorage.setItem('user', JSON.stringify(data.data.user));\n            localStorage.setItem('token', data.data.token);\n            return {\n                message: 'Login successful',\n                data\n            };\n        } catch (error) {\n            var _error_data_error, _error_data, _error_data1;\n            // error is actually the object returned from fetchApi with { ok, status, data, message }\n            if (error.status === 400 && ((_error_data = error.data) === null || _error_data === void 0 ? void 0 : (_error_data_error = _error_data.error) === null || _error_data_error === void 0 ? void 0 : _error_data_error.type) === 'NUMBERVERIFY' && ((_error_data1 = error.data) === null || _error_data1 === void 0 ? void 0 : _error_data1.data)) {\n                const userData = error.data.data;\n                localStorage.setItem('user', JSON.stringify({\n                    _id: userData._id,\n                    username: userData.username || userData.email.split('@')[0],\n                    email: userData.email,\n                    role: userData.userType\n                }));\n                localStorage.setItem('token', \"temp_\".concat(userData._id));\n                return error.data;\n            }\n            // For other errors, throw or return a useful error message\n            throw new Error(error.message || 'Login failed');\n        }\n    },\n    /**\n   * Verify OTP - handles optional number verification\n   */ verifyOtp: async (email, otp)=>{\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.post(\"api/v1/user/otp-verify\", {\n                email,\n                otp\n            });\n            // Check if we have user data even with a 400 status\n            if (response.data && response.status) {\n                // Store user data in localStorage\n                const userData = {\n                    _id: response.data._id,\n                    username: response.data.username,\n                    email: response.data.email,\n                    role: response.data.userType\n                };\n                localStorage.setItem(\"user\", JSON.stringify(userData));\n                // For now, we'll use a temporary token since the API doesn't provide one\n                // You might want to get a proper token from the login endpoint\n                localStorage.setItem(\"token\", \"temp_\".concat(response.data._id));\n            }\n            return response;\n        } catch (error) {\n            var _error_response, _error_response_data_error, _error_response_data, _error_response1;\n            // Check if it's a 400 error with NUMBERVERIFY type (which is acceptable)\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 400 && ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : (_error_response_data_error = _error_response_data.error) === null || _error_response_data_error === void 0 ? void 0 : _error_response_data_error.type) === \"NUMBERVERIFY\") {\n                const responseData = error.response.data;\n                // If we have user data and the status is true, treat it as success\n                if (responseData.data && responseData.status) {\n                    const userData = {\n                        _id: responseData.data._id,\n                        username: responseData.data.username,\n                        email: responseData.data.email,\n                        role: responseData.data.userType\n                    };\n                    localStorage.setItem(\"user\", JSON.stringify(userData));\n                    localStorage.setItem(\"token\", \"temp_\".concat(responseData.data._id));\n                    return responseData;\n                }\n            }\n            console.error(\"Failed to verify OTP:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Resend OTP\n   */ resendOtp: async (email)=>{\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.post(\"api/v1/user/resend-otp\", {\n                email\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Failed to resend OTP:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Check if user is logged in\n   */ isLoggedIn: ()=>{\n        if (false) {}\n        return !!localStorage.getItem(\"token\");\n    },\n    /**\n   * Get current user\n   */ getCurrentUser: ()=>{\n        if (false) {}\n        const userStr = localStorage.getItem(\"user\");\n        return userStr ? JSON.parse(userStr) : null;\n    },\n    /**\n   * Logout user\n   */ logout: ()=>{\n        if (false) {}\n        localStorage.removeItem(\"user\");\n        localStorage.removeItem(\"token\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2F1dGgtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQXlEL0I7O0NBRUMsR0FDTSxNQUFNQyxjQUFjO0lBRXpCOztHQUVDLEdBQ0RDLFVBQVUsZUFDUkMsT0FDQUM7WUFDQUMsNEVBQVcsVUFDWEMsNkVBQVk7UUFFWixJQUFJO1lBQ0YsTUFBTUMsV0FBVyxNQUFNUCx5Q0FBR0EsQ0FBQ1EsSUFBSSxDQUFtQix3QkFBd0I7Z0JBQ3hFTDtnQkFDQUM7Z0JBQ0FDO2dCQUNBQztZQUNGO1lBQ0EsT0FBT0M7UUFDVCxFQUFFLE9BQU9FLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDREUsT0FBTyxPQUFPUixPQUFlRTtRQUM3QixJQUFJO1lBQ0YsTUFBTU8sT0FBTyxNQUFNWix5Q0FBR0EsQ0FBQ1EsSUFBSSxDQUFlLDBCQUEwQjtnQkFBRUw7Z0JBQU9FO1lBQVM7WUFFdEZRLGFBQWFDLE9BQU8sQ0FBQyxRQUFRQyxLQUFLQyxTQUFTLENBQUNKLEtBQUtBLElBQUksQ0FBQ0ssSUFBSTtZQUMxREosYUFBYUMsT0FBTyxDQUFDLFNBQVNGLEtBQUtBLElBQUksQ0FBQ00sS0FBSztZQUU3QyxPQUFPO2dCQUFFQyxTQUFTO2dCQUFvQlA7WUFBSztRQUM3QyxFQUFFLE9BQU9ILE9BQVk7Z0JBS2pCQSxtQkFBQUEsYUFDQUE7WUFMRix5RkFBeUY7WUFFekYsSUFDRUEsTUFBTVcsTUFBTSxLQUFLLE9BQ2pCWCxFQUFBQSxjQUFBQSxNQUFNRyxJQUFJLGNBQVZILG1DQUFBQSxvQkFBQUEsWUFBWUEsS0FBSyxjQUFqQkEsd0NBQUFBLGtCQUFtQlksSUFBSSxNQUFLLG9CQUM1QlosZUFBQUEsTUFBTUcsSUFBSSxjQUFWSCxtQ0FBQUEsYUFBWUcsSUFBSSxHQUNoQjtnQkFDQSxNQUFNVSxXQUFXYixNQUFNRyxJQUFJLENBQUNBLElB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UjtJQUNGO0lBRUE7O0dBRUMsR0FDRHVCLFlBQVk7UUFDVixJQUFJLEtBQTZCLEVBQUUsRUFBTztRQUMxQyxPQUFPLENBQUMsQ0FBQ25CLGFBQWFvQixPQUFPLENBQUM7SUFDaEM7SUFFQTs7R0FFQyxHQUNEQyxnQkFBZ0I7UUFDZCxJQUFJLEtBQTZCLEVBQUUsRUFBTztRQUMxQyxNQUFNQyxVQUFVdEIsYUFBYW9CLE9BQU8sQ0FBQztRQUNyQyxPQUFPRSxVQUFVcEIsS0FBS3FCLEtBQUssQ0FBQ0QsV0FBVztJQUN6QztJQUVBOztHQUVDLEdBQ0RFLFFBQVE7UUFDTixJQUFJLEtBQTZCLEVBQUU7UUFDbkN4QixhQUFheUIsVUFBVSxDQUFDO1FBQ3hCekIsYUFBYXlCLFVBQVUsQ0FBQztJQUMxQjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaHBcXERlc2t0b3BcXGFyZGVsaXZlcm93ZWItcGVyZmVjdCAoMilcXHNlcnZpY2VzXFxhdXRoLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBpIH0gZnJvbSBcIkAvbGliL2FwaVwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIF9pZDogc3RyaW5nXG4gIHVzZXJuYW1lOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICByb2xlOiBzdHJpbmdcbiAgdG9rZW4/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoUmVzcG9uc2Uge1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgZGF0YToge1xuICAgIHVzZXI6IFVzZXJcbiAgICB0b2tlbjogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RlclJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGRhdGE6IHtcbiAgICBlbWFpbDogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdHBWZXJpZnlSZXNwb25zZSB7XG4gIHN0YXR1czogYm9vbGVhblxuICBjb2RlOiBudW1iZXJcbiAgZGF0YToge1xuICAgIF9pZDogc3RyaW5nXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xuICAgIGVtYWlsOiBzdHJpbmdcbiAgICB1c2VyVHlwZTogc3RyaW5nXG4gICAgcGFzc3dvcmQ6IHN0cmluZ1xuICAgIHBsYWluUGFzc3dvcmQ6IHN0cmluZ1xuICAgIG90cENvZGU6IHN0cmluZ1xuICAgIHVpZDogc3RyaW5nXG4gICAgaXNWZXJpZnlFbWFpbDogYm9vbGVhblxuICAgIGlzVmVyaWZ5TnVtYmVyOiBib29sZWFuXG4gICAgbnVtYmVyOiBzdHJpbmdcbiAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgIGxhc3ROYW1lOiBzdHJpbmdcbiAgICBpbWFnZTogc3RyaW5nXG4gICAgb3RwRXhwaXJlc0F0OiBzdHJpbmdcbiAgICB0b2tlbkZDTTogc3RyaW5nXG4gICAgc3RhdHVzOiBib29sZWFuXG4gICAgdXNlclN0YXR1czogc3RyaW5nXG4gICAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgICB1cGRhdGVkQXQ6IHN0cmluZ1xuICAgIF9fdjogbnVtYmVyXG4gIH1cbiAgZXJyb3I/OiB7XG4gICAgdHlwZTogc3RyaW5nXG4gICAgbWVzc2FnZTogc3RyaW5nXG4gIH1cbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBhdXRoZW50aWNhdGlvbi1yZWxhdGVkIEFQSSBjYWxsc1xuICovXG5leHBvcnQgY29uc3QgQXV0aFNlcnZpY2UgPSB7XG4gXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIG5ldyB1c2VyXG4gICAqL1xuICByZWdpc3RlcjogYXN5bmMgKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgdXNlcm5hbWU6IHN0cmluZyxcbiAgICBwYXNzd29yZCA9IFwiMTIzNDU2XCIsXG4gICAgbG9naW5UeXBlID0gXCJlbWFpbFwiLFxuICApOiBQcm9taXNlPFJlZ2lzdGVyUmVzcG9uc2U+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdDxSZWdpc3RlclJlc3BvbnNlPihcImFwaS92MS91c2VyL3JlZ2lzdGVyXCIsIHtcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHVzZXJuYW1lLFxuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgbG9naW5UeXBlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlZ2lzdGVyIHVzZXI6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvZ2luIGEgdXNlclxuICAgKi9cbiAgbG9naW46IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxBdXRoUmVzcG9uc2UgfCBhbnk+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgYXBpLnBvc3Q8QXV0aFJlc3BvbnNlPignYXBpL3YxL3VzZXIvdXNlci1sb2dpbicsIHsgZW1haWwsIHBhc3N3b3JkIH0pXG5cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlcicsIEpTT04uc3RyaW5naWZ5KGRhdGEuZGF0YS51c2VyKSlcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndG9rZW4nLCBkYXRhLmRhdGEudG9rZW4pXG5cbiAgICByZXR1cm4geyBtZXNzYWdlOiAnTG9naW4gc3VjY2Vzc2Z1bCcsIGRhdGEgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgLy8gZXJyb3IgaXMgYWN0dWFsbHkgdGhlIG9iamVjdCByZXR1cm5lZCBmcm9tIGZldGNoQXBpIHdpdGggeyBvaywgc3RhdHVzLCBkYXRhLCBtZXNzYWdlIH1cblxuICAgIGlmIChcbiAgICAgIGVycm9yLnN0YXR1cyA9PT0gNDAwICYmXG4gICAgICBlcnJvci5kYXRhPy5lcnJvcj8udHlwZSA9PT0gJ05VTUJFUlZFUklGWScgJiZcbiAgICAgIGVycm9yLmRhdGE/LmRhdGFcbiAgICApIHtcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gZXJyb3IuZGF0YS5kYXRhXG5cbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAndXNlcicsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBfaWQ6IHVzZXJEYXRhLl9pZCxcbiAgICAgICAgICB1c2VybmFtZTogdXNlckRhdGEudXNlcm5hbWUgfHwgdXNlckRhdGEuZW1haWwuc3BsaXQoJ0AnKVswXSxcbiAgICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXG4gICAgICAgICAgcm9sZTogdXNlckRhdGEudXNlclR5cGUsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndG9rZW4nLCBgdGVtcF8ke3VzZXJEYXRhLl9pZH1gKVxuXG4gICAgICByZXR1cm4gZXJyb3IuZGF0YVxuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBlcnJvcnMsIHRocm93IG9yIHJldHVybiBhIHVzZWZ1bCBlcnJvciBtZXNzYWdlXG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgJ0xvZ2luIGZhaWxlZCcpXG4gIH1cbn0sXG5cblxuICAvKipcbiAgICogVmVyaWZ5IE9UUCAtIGhhbmRsZXMgb3B0aW9uYWwgbnVtYmVyIHZlcmlmaWNhdGlvblxuICAgKi9cbiAgdmVyaWZ5T3RwOiBhc3luYyAoZW1haWw6IHN0cmluZywgb3RwOiBzdHJpbmcpOiBQcm9taXNlPE90cFZlcmlmeVJlc3BvbnNlPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3Q8T3RwVmVyaWZ5UmVzcG9uc2U+KFwiYXBpL3YxL3VzZXIvb3RwLXZlcmlmeVwiLCB7XG4gICAgICAgIGVtYWlsLFxuICAgICAgICBvdHAsXG4gICAgICB9KVxuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHVzZXIgZGF0YSBldmVuIHdpdGggYSA0MDAgc3RhdHVzXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgLy8gU3RvcmUgdXNlciBkYXRhIGluIGxvY2FsU3RvcmFnZVxuICAgICAgICBjb25zdCB1c2VyRGF0YSA9IHtcbiAgICAgICAgICBfaWQ6IHJlc3BvbnNlLmRhdGEuX2lkLFxuICAgICAgICAgIHVzZXJuYW1lOiByZXNwb25zZS5kYXRhLnVzZXJuYW1lLFxuICAgICAgICAgIGVtYWlsOiByZXNwb25zZS5kYXRhLmVtYWlsLFxuICAgICAgICAgIHJvbGU6IHJlc3BvbnNlLmRhdGEudXNlclR5cGUsXG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyXCIsIEpTT04uc3RyaW5naWZ5KHVzZXJEYXRhKSlcblxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCB1c2UgYSB0ZW1wb3JhcnkgdG9rZW4gc2luY2UgdGhlIEFQSSBkb2Vzbid0IHByb3ZpZGUgb25lXG4gICAgICAgIC8vIFlvdSBtaWdodCB3YW50IHRvIGdldCBhIHByb3BlciB0b2tlbiBmcm9tIHRoZSBsb2dpbiBlbmRwb2ludFxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRva2VuXCIsIGB0ZW1wXyR7cmVzcG9uc2UuZGF0YS5faWR9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIDQwMCBlcnJvciB3aXRoIE5VTUJFUlZFUklGWSB0eXBlICh3aGljaCBpcyBhY2NlcHRhYmxlKVxuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMCAmJiBlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3I/LnR5cGUgPT09IFwiTlVNQkVSVkVSSUZZXCIpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZXJyb3IucmVzcG9uc2UuZGF0YSBhcyBPdHBWZXJpZnlSZXNwb25zZVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgdXNlciBkYXRhIGFuZCB0aGUgc3RhdHVzIGlzIHRydWUsIHRyZWF0IGl0IGFzIHN1Y2Nlc3NcbiAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5kYXRhICYmIHJlc3BvbnNlRGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IHtcbiAgICAgICAgICAgIF9pZDogcmVzcG9uc2VEYXRhLmRhdGEuX2lkLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHJlc3BvbnNlRGF0YS5kYXRhLnVzZXJuYW1lLFxuICAgICAgICAgICAgZW1haWw6IHJlc3BvbnNlRGF0YS5kYXRhLmVtYWlsLFxuICAgICAgICAgICAgcm9sZTogcmVzcG9uc2VEYXRhLmRhdGEudXNlclR5cGUsXG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlclwiLCBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSkpXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0b2tlblwiLCBgdGVtcF8ke3Jlc3BvbnNlRGF0YS5kYXRhLl9pZH1gKVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0YVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gdmVyaWZ5IE9UUDpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZW5kIE9UUFxuICAgKi9cbiAgcmVzZW5kT3RwOiBhc3luYyAoZW1haWw6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0PHsgbWVzc2FnZTogc3RyaW5nIH0+KFwiYXBpL3YxL3VzZXIvcmVzZW5kLW90cFwiLCB7XG4gICAgICAgIGVtYWlsLFxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlc2VuZCBPVFA6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHVzZXIgaXMgbG9nZ2VkIGluXG4gICAqL1xuICBpc0xvZ2dlZEluOiAoKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiAhIWxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5cIilcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdXNlclxuICAgKi9cbiAgZ2V0Q3VycmVudFVzZXI6ICgpOiBVc2VyIHwgbnVsbCA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG4gICAgY29uc3QgdXNlclN0ciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlclwiKVxuICAgIHJldHVybiB1c2VyU3RyID8gSlNPTi5wYXJzZSh1c2VyU3RyKSA6IG51bGxcbiAgfSxcblxuICAvKipcbiAgICogTG9nb3V0IHVzZXJcbiAgICovXG4gIGxvZ291dDogKCk6IHZvaWQgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInVzZXJcIilcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInRva2VuXCIpXG4gIH0sXG59XG4iXSwibmFtZXMiOlsiYXBpIiwiQXV0aFNlcnZpY2UiLCJyZWdpc3RlciIsImVtYWlsIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImxvZ2luVHlwZSIsInJlc3BvbnNlIiwicG9zdCIsImVycm9yIiwiY29uc29sZSIsImxvZ2luIiwiZGF0YSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwidXNlciIsInRva2VuIiwibWVzc2FnZSIsInN0YXR1cyIsInR5cGUiLCJ1c2VyRGF0YSIsIl9pZCIsInNwbGl0Iiwicm9sZSIsInVzZXJUeXBlIiwiRXJyb3IiLCJ2ZXJpZnlPdHAiLCJvdHAiLCJyZXNwb25zZURhdGEiLCJyZXNlbmRPdHAiLCJpc0xvZ2dlZEluIiwiZ2V0SXRlbSIsImdldEN1cnJlbnRVc2VyIiwidXNlclN0ciIsInBhcnNlIiwibG9nb3V0IiwicmVtb3ZlSXRlbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/auth-service.ts\n"));

/***/ })

});