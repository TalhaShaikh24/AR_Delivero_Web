"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/checkout/page",{

/***/ "(app-pages-browser)/./services/auth-service.ts":
/*!**********************************!*\
  !*** ./services/auth-service.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthService: () => (/* binding */ AuthService)\n/* harmony export */ });\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n\n/**\n * Service for authentication-related API calls\n */ const AuthService = {\n    /**\n   * Register a new user\n   */ register: async function(email, username) {\n        let password = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"123456\", loginType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"email\";\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.post(\"api/v1/user/register\", {\n                email,\n                username,\n                password,\n                loginType\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Failed to register user:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Login a user\n   */ login: async (email, password)=>{\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.post('api/v1/user/user-login', {\n                email,\n                password\n            });\n            localStorage.setItem('user', JSON.stringify(data.data.user));\n            localStorage.setItem('token', data.data.token);\n            return {\n                message: 'Login successful',\n                data\n            };\n        } catch (error) {\n            var _error_data_error, _error_data, _error_data1;\n            // error is actually the object returned from fetchApi with { ok, status, data, message }\n            debugger;\n            if (error.code === 400 && ((_error_data = error.data) === null || _error_data === void 0 ? void 0 : (_error_data_error = _error_data.error) === null || _error_data_error === void 0 ? void 0 : _error_data_error.type) === 'NUMBERVERIFY' && ((_error_data1 = error.data) === null || _error_data1 === void 0 ? void 0 : _error_data1.data)) {\n                const userData = error.data.data;\n                localStorage.setItem('user', JSON.stringify({\n                    _id: userData._id,\n                    username: userData.username || userData.email.split('@')[0],\n                    email: userData.email,\n                    role: userData.userType\n                }));\n                localStorage.setItem('token', \"temp_\".concat(userData._id));\n                return error.data;\n            }\n            // For other errors, throw or return a useful error message\n            throw new Error(error.message || 'Login failed');\n        }\n    },\n    /**\n   * Verify OTP - handles optional number verification\n   */ verifyOtp: async (email, otp)=>{\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.post(\"api/v1/user/otp-verify\", {\n                email,\n                otp\n            });\n            // Check if we have user data even with a 400 status\n            if (response.data && response.status) {\n                // Store user data in localStorage\n                const userData = {\n                    _id: response.data._id,\n                    username: response.data.username,\n                    email: response.data.email,\n                    role: response.data.userType\n                };\n                localStorage.setItem(\"user\", JSON.stringify(userData));\n                // For now, we'll use a temporary token since the API doesn't provide one\n                // You might want to get a proper token from the login endpoint\n                localStorage.setItem(\"token\", \"temp_\".concat(response.data._id));\n            }\n            return response;\n        } catch (error) {\n            var _error_response, _error_response_data_error, _error_response_data, _error_response1;\n            // Check if it's a 400 error with NUMBERVERIFY type (which is acceptable)\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 400 && ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : (_error_response_data_error = _error_response_data.error) === null || _error_response_data_error === void 0 ? void 0 : _error_response_data_error.type) === \"NUMBERVERIFY\") {\n                const responseData = error.response.data;\n                // If we have user data and the status is true, treat it as success\n                if (responseData.data && responseData.status) {\n                    const userData = {\n                        _id: responseData.data._id,\n                        username: responseData.data.username,\n                        email: responseData.data.email,\n                        role: responseData.data.userType\n                    };\n                    localStorage.setItem(\"user\", JSON.stringify(userData));\n                    localStorage.setItem(\"token\", \"temp_\".concat(responseData.data._id));\n                    return responseData;\n                }\n            }\n            console.error(\"Failed to verify OTP:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Resend OTP\n   */ resendOtp: async (email)=>{\n        try {\n            const response = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.api.post(\"api/v1/user/resend-otp\", {\n                email\n            });\n            return response;\n        } catch (error) {\n            console.error(\"Failed to resend OTP:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Check if user is logged in\n   */ isLoggedIn: ()=>{\n        if (false) {}\n        return !!localStorage.getItem(\"token\");\n    },\n    /**\n   * Get current user\n   */ getCurrentUser: ()=>{\n        if (false) {}\n        const userStr = localStorage.getItem(\"user\");\n        return userStr ? JSON.parse(userStr) : null;\n    },\n    /**\n   * Logout user\n   */ logout: ()=>{\n        if (false) {}\n        localStorage.removeItem(\"user\");\n        localStorage.removeItem(\"token\");\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2F1dGgtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQXlEL0I7O0NBRUMsR0FDTSxNQUFNQyxjQUFjO0lBRXpCOztHQUVDLEdBQ0RDLFVBQVUsZUFDUkMsT0FDQUM7WUFDQUMsNEVBQVcsVUFDWEMsNkVBQVk7UUFFWixJQUFJO1lBQ0YsTUFBTUMsV0FBVyxNQUFNUCx5Q0FBR0EsQ0FBQ1EsSUFBSSxDQUFtQix3QkFBd0I7Z0JBQ3hFTDtnQkFDQUM7Z0JBQ0FDO2dCQUNBQztZQUNGO1lBQ0EsT0FBT0M7UUFDVCxFQUFFLE9BQU9FLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDREUsT0FBTyxPQUFPUixPQUFlRTtRQUM3QixJQUFJO1lBQ0YsTUFBTU8sT0FBTyxNQUFNWix5Q0FBR0EsQ0FBQ1EsSUFBSSxDQUFlLDBCQUEwQjtnQkFBRUw7Z0JBQU9FO1lBQVM7WUFFdEZRLGFBQWFDLE9BQU8sQ0FBQyxRQUFRQyxLQUFLQyxTQUFTLENBQUNKLEtBQUtBLElBQUksQ0FBQ0ssSUFBSTtZQUMxREosYUFBYUMsT0FBTyxDQUFDLFNBQVNGLEtBQUtBLElBQUksQ0FBQ00sS0FBSztZQUU3QyxPQUFPO2dCQUFFQyxTQUFTO2dCQUFvQlA7WUFBSztRQUM3QyxFQUFFLE9BQU9ILE9BQVk7Z0JBS2pCQSxtQkFBQUEsYUFDQUE7WUFMRix5RkFBeUY7WUFDN0YsUUFBUztZQUNMLElBQ0VBLE1BQU1XLElBQUksS0FBSyxPQUNmWCxFQUFBQSxjQUFBQSxNQUFNRyxJQUFJLGNBQVZILG1DQUFBQSxvQkFBQUEsWUFBWUEsS0FBSyxjQUFqQkEsd0NBQUFBLGtCQUFtQlksSUFBSSxNQUFLLG9CQUM1QlosZUFBQUEsTUFBTUcsSUFBSSxjQUFWSCxtQ0FBQUEsYUFBWUcsSUFBSSxHQUNoQjtnQkFDQSxNQUFNVSxXQUFXYixNQUFNRyxJQUFJ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dkMsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRHdCLFlBQVk7UUFDVixJQUFJLEtBQTZCLEVBQUUsRUFBTztRQUMxQyxPQUFPLENBQUMsQ0FBQ3BCLGFBQWFxQixPQUFPLENBQUM7SUFDaEM7SUFFQTs7R0FFQyxHQUNEQyxnQkFBZ0I7UUFDZCxJQUFJLEtBQTZCLEVBQUUsRUFBTztRQUMxQyxNQUFNQyxVQUFVdkIsYUFBYXFCLE9BQU8sQ0FBQztRQUNyQyxPQUFPRSxVQUFVckIsS0FBS3NCLEtBQUssQ0FBQ0QsV0FBVztJQUN6QztJQUVBOztHQUVDLEdBQ0RFLFFBQVE7UUFDTixJQUFJLEtBQTZCLEVBQUU7UUFDbkN6QixhQUFhMEIsVUFBVSxDQUFDO1FBQ3hCMUIsYUFBYTBCLFVBQVUsQ0FBQztJQUMxQjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaHBcXERlc2t0b3BcXGFyZGVsaXZlcm93ZWItcGVyZmVjdCAoMilcXHNlcnZpY2VzXFxhdXRoLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBpIH0gZnJvbSBcIkAvbGliL2FwaVwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIF9pZDogc3RyaW5nXG4gIHVzZXJuYW1lOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICByb2xlOiBzdHJpbmdcbiAgdG9rZW4/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoUmVzcG9uc2Uge1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgZGF0YToge1xuICAgIHVzZXI6IFVzZXJcbiAgICB0b2tlbjogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RlclJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGRhdGE6IHtcbiAgICBlbWFpbDogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdHBWZXJpZnlSZXNwb25zZSB7XG4gIHN0YXR1czogYm9vbGVhblxuICBjb2RlOiBudW1iZXJcbiAgZGF0YToge1xuICAgIF9pZDogc3RyaW5nXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xuICAgIGVtYWlsOiBzdHJpbmdcbiAgICB1c2VyVHlwZTogc3RyaW5nXG4gICAgcGFzc3dvcmQ6IHN0cmluZ1xuICAgIHBsYWluUGFzc3dvcmQ6IHN0cmluZ1xuICAgIG90cENvZGU6IHN0cmluZ1xuICAgIHVpZDogc3RyaW5nXG4gICAgaXNWZXJpZnlFbWFpbDogYm9vbGVhblxuICAgIGlzVmVyaWZ5TnVtYmVyOiBib29sZWFuXG4gICAgbnVtYmVyOiBzdHJpbmdcbiAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgIGxhc3ROYW1lOiBzdHJpbmdcbiAgICBpbWFnZTogc3RyaW5nXG4gICAgb3RwRXhwaXJlc0F0OiBzdHJpbmdcbiAgICB0b2tlbkZDTTogc3RyaW5nXG4gICAgc3RhdHVzOiBib29sZWFuXG4gICAgdXNlclN0YXR1czogc3RyaW5nXG4gICAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgICB1cGRhdGVkQXQ6IHN0cmluZ1xuICAgIF9fdjogbnVtYmVyXG4gIH1cbiAgZXJyb3I/OiB7XG4gICAgdHlwZTogc3RyaW5nXG4gICAgbWVzc2FnZTogc3RyaW5nXG4gIH1cbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBhdXRoZW50aWNhdGlvbi1yZWxhdGVkIEFQSSBjYWxsc1xuICovXG5leHBvcnQgY29uc3QgQXV0aFNlcnZpY2UgPSB7XG4gXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIG5ldyB1c2VyXG4gICAqL1xuICByZWdpc3RlcjogYXN5bmMgKFxuICAgIGVtYWlsOiBzdHJpbmcsXG4gICAgdXNlcm5hbWU6IHN0cmluZyxcbiAgICBwYXNzd29yZCA9IFwiMTIzNDU2XCIsXG4gICAgbG9naW5UeXBlID0gXCJlbWFpbFwiLFxuICApOiBQcm9taXNlPFJlZ2lzdGVyUmVzcG9uc2U+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdDxSZWdpc3RlclJlc3BvbnNlPihcImFwaS92MS91c2VyL3JlZ2lzdGVyXCIsIHtcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHVzZXJuYW1lLFxuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgbG9naW5UeXBlLFxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlZ2lzdGVyIHVzZXI6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvZ2luIGEgdXNlclxuICAgKi9cbiAgbG9naW46IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxBdXRoUmVzcG9uc2UgfCBhbnk+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgYXBpLnBvc3Q8QXV0aFJlc3BvbnNlPignYXBpL3YxL3VzZXIvdXNlci1sb2dpbicsIHsgZW1haWwsIHBhc3N3b3JkIH0pXG5cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlcicsIEpTT04uc3RyaW5naWZ5KGRhdGEuZGF0YS51c2VyKSlcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndG9rZW4nLCBkYXRhLmRhdGEudG9rZW4pXG5cbiAgICByZXR1cm4geyBtZXNzYWdlOiAnTG9naW4gc3VjY2Vzc2Z1bCcsIGRhdGEgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgLy8gZXJyb3IgaXMgYWN0dWFsbHkgdGhlIG9iamVjdCByZXR1cm5lZCBmcm9tIGZldGNoQXBpIHdpdGggeyBvaywgc3RhdHVzLCBkYXRhLCBtZXNzYWdlIH1cbmRlYnVnZ2VyO1xuICAgIGlmIChcbiAgICAgIGVycm9yLmNvZGUgPT09IDQwMCAmJlxuICAgICAgZXJyb3IuZGF0YT8uZXJyb3I/LnR5cGUgPT09ICdOVU1CRVJWRVJJRlknICYmXG4gICAgICBlcnJvci5kYXRhPy5kYXRhXG4gICAgKSB7XG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGVycm9yLmRhdGEuZGF0YVxuXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgJ3VzZXInLFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgX2lkOiB1c2VyRGF0YS5faWQsXG4gICAgICAgICAgdXNlcm5hbWU6IHVzZXJEYXRhLnVzZXJuYW1lIHx8IHVzZXJEYXRhLmVtYWlsLnNwbGl0KCdAJylbMF0sXG4gICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxuICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnVzZXJUeXBlLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rva2VuJywgYHRlbXBfJHt1c2VyRGF0YS5faWR9YClcblxuICAgICAgcmV0dXJuIGVycm9yLmRhdGFcbiAgICB9XG5cbiAgICAvLyBGb3Igb3RoZXIgZXJyb3JzLCB0aHJvdyBvciByZXR1cm4gYSB1c2VmdWwgZXJyb3IgbWVzc2FnZVxuICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdMb2dpbiBmYWlsZWQnKVxuICB9XG59LFxuXG5cbiAgLyoqXG4gICAqIFZlcmlmeSBPVFAgLSBoYW5kbGVzIG9wdGlvbmFsIG51bWJlciB2ZXJpZmljYXRpb25cbiAgICovXG4gIHZlcmlmeU90cDogYXN5bmMgKGVtYWlsOiBzdHJpbmcsIG90cDogc3RyaW5nKTogUHJvbWlzZTxPdHBWZXJpZnlSZXNwb25zZT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0PE90cFZlcmlmeVJlc3BvbnNlPihcImFwaS92MS91c2VyL290cC12ZXJpZnlcIiwge1xuICAgICAgICBlbWFpbCxcbiAgICAgICAgb3RwLFxuICAgICAgfSlcblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB1c2VyIGRhdGEgZXZlbiB3aXRoIGEgNDAwIHN0YXR1c1xuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgIC8vIFN0b3JlIHVzZXIgZGF0YSBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgY29uc3QgdXNlckRhdGEgPSB7XG4gICAgICAgICAgX2lkOiByZXNwb25zZS5kYXRhLl9pZCxcbiAgICAgICAgICB1c2VybmFtZTogcmVzcG9uc2UuZGF0YS51c2VybmFtZSxcbiAgICAgICAgICBlbWFpbDogcmVzcG9uc2UuZGF0YS5lbWFpbCxcbiAgICAgICAgICByb2xlOiByZXNwb25zZS5kYXRhLnVzZXJUeXBlLFxuICAgICAgICB9XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlclwiLCBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSkpXG5cbiAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgdXNlIGEgdGVtcG9yYXJ5IHRva2VuIHNpbmNlIHRoZSBBUEkgZG9lc24ndCBwcm92aWRlIG9uZVxuICAgICAgICAvLyBZb3UgbWlnaHQgd2FudCB0byBnZXQgYSBwcm9wZXIgdG9rZW4gZnJvbSB0aGUgbG9naW4gZW5kcG9pbnRcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0b2tlblwiLCBgdGVtcF8ke3Jlc3BvbnNlLmRhdGEuX2lkfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSA0MDAgZXJyb3Igd2l0aCBOVU1CRVJWRVJJRlkgdHlwZSAod2hpY2ggaXMgYWNjZXB0YWJsZSlcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDAgJiYgZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yPy50eXBlID09PSBcIk5VTUJFUlZFUklGWVwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGVycm9yLnJlc3BvbnNlLmRhdGEgYXMgT3RwVmVyaWZ5UmVzcG9uc2VcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIHVzZXIgZGF0YSBhbmQgdGhlIHN0YXR1cyBpcyB0cnVlLCB0cmVhdCBpdCBhcyBzdWNjZXNzXG4gICAgICAgIGlmIChyZXNwb25zZURhdGEuZGF0YSAmJiByZXNwb25zZURhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY29uc3QgdXNlckRhdGEgPSB7XG4gICAgICAgICAgICBfaWQ6IHJlc3BvbnNlRGF0YS5kYXRhLl9pZCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiByZXNwb25zZURhdGEuZGF0YS51c2VybmFtZSxcbiAgICAgICAgICAgIGVtYWlsOiByZXNwb25zZURhdGEuZGF0YS5lbWFpbCxcbiAgICAgICAgICAgIHJvbGU6IHJlc3BvbnNlRGF0YS5kYXRhLnVzZXJUeXBlLFxuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJcIiwgSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpKVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidG9rZW5cIiwgYHRlbXBfJHtyZXNwb25zZURhdGEuZGF0YS5faWR9YClcblxuICAgICAgICAgIHJldHVybiByZXNwb25zZURhdGFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHZlcmlmeSBPVFA6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2VuZCBPVFBcbiAgICovXG4gIHJlc2VuZE90cDogYXN5bmMgKGVtYWlsOiBzdHJpbmcpOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdDx7IG1lc3NhZ2U6IHN0cmluZyB9PihcImFwaS92MS91c2VyL3Jlc2VuZC1vdHBcIiwge1xuICAgICAgICBlbWFpbCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byByZXNlbmQgT1RQOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB1c2VyIGlzIGxvZ2dlZCBpblxuICAgKi9cbiAgaXNMb2dnZWRJbjogKCk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gISFsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuXCIpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHVzZXJcbiAgICovXG4gIGdldEN1cnJlbnRVc2VyOiAoKTogVXNlciB8IG51bGwgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IHVzZXJTdHIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJcIilcbiAgICByZXR1cm4gdXNlclN0ciA/IEpTT04ucGFyc2UodXNlclN0cikgOiBudWxsXG4gIH0sXG5cbiAgLyoqXG4gICAqIExvZ291dCB1c2VyXG4gICAqL1xuICBsb2dvdXQ6ICgpOiB2b2lkID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJ1c2VyXCIpXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJ0b2tlblwiKVxuICB9LFxufVxuIl0sIm5hbWVzIjpbImFwaSIsIkF1dGhTZXJ2aWNlIiwicmVnaXN0ZXIiLCJlbWFpbCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJsb2dpblR5cGUiLCJyZXNwb25zZSIsInBvc3QiLCJlcnJvciIsImNvbnNvbGUiLCJsb2dpbiIsImRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInVzZXIiLCJ0b2tlbiIsIm1lc3NhZ2UiLCJjb2RlIiwidHlwZSIsInVzZXJEYXRhIiwiX2lkIiwic3BsaXQiLCJyb2xlIiwidXNlclR5cGUiLCJFcnJvciIsInZlcmlmeU90cCIsIm90cCIsInN0YXR1cyIsInJlc3BvbnNlRGF0YSIsInJlc2VuZE90cCIsImlzTG9nZ2VkSW4iLCJnZXRJdGVtIiwiZ2V0Q3VycmVudFVzZXIiLCJ1c2VyU3RyIiwicGFyc2UiLCJsb2dvdXQiLCJyZW1vdmVJdGVtIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/auth-service.ts\n"));

/***/ })

});